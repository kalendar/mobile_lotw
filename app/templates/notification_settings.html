{% extends "index.html" %}

{% block content %}
  <form method="post" action="{{ settings_url }}" class="text-start mx-auto" style="max-width: 640px">
    <div class="mb-3 form-check">
      <input
        class="form-check-input"
        type="checkbox"
        id="qsl_digest_enabled"
        name="qsl_digest_enabled"
        {% if preference.qsl_digest_enabled %}checked{% endif %}
      />
      <label class="form-check-label" for="qsl_digest_enabled">Enable daily QSL digest notifications</label>
    </div>

    <div class="mb-3">
      <label for="qsl_digest_time_local" class="form-label">Digest send time (local)</label>
      <input
        class="form-control"
        type="time"
        id="qsl_digest_time_local"
        name="qsl_digest_time_local"
        value="{{ preference.qsl_digest_time_local.strftime('%H:%M') }}"
      />
    </div>

    <div class="mb-3">
      <label for="timezone" class="form-label">Timezone (IANA)</label>
      <select class="form-select" id="timezone" name="timezone">
        {% for timezone_value, timezone_label in timezone_options %}
          <option value="{{ timezone_value }}" {% if (user.timezone or "UTC") == timezone_value %}selected{% endif %}>
            {{ timezone_label }}
          </option>
        {% endfor %}
      </select>
      <div class="form-text">Choose the timezone used for your daily digest send time.</div>
    </div>

    <div class="mb-3">
      <label for="locale" class="form-label">Locale (optional)</label>
      <input class="form-control" type="text" id="locale" name="locale" value="{{ user.locale or '' }}" />
    </div>

    <div class="mb-3 form-check">
      <input
        class="form-check-input"
        type="checkbox"
        id="fallback_to_email"
        name="fallback_to_email"
        {% if preference.fallback_to_email %}checked{% endif %}
      />
      <label class="form-check-label" for="fallback_to_email">Fallback to email when web push is unavailable</label>
    </div>

    <button type="submit" class="btn btn-primary">Save settings</button>
  </form>

  <hr class="my-4" />

  <div class="text-start mx-auto" style="max-width: 640px">
    <h4>Web Push</h4>
    <p>
      Active browser subscriptions: <strong id="push-count">{{ active_web_push_count }}</strong>
    </p>
    <button id="enable-push-btn" class="btn btn-success me-2" type="button">Enable browser push</button>
    <button id="disable-push-btn" class="btn btn-outline-secondary" type="button">Disable browser push</button>
    <p class="mt-3 mb-0"><small id="push-status"></small></p>
  </div>
{% endblock %}

{% block scripts %}
  <script>
    const pushStatus = document.getElementById("push-status");
    const pushCount = document.getElementById("push-count");
    const publicVapidKey = "{{ web_push_public_key }}";

    function updateStatus(message, isError = false) {
      pushStatus.textContent = message;
      pushStatus.style.color = isError ? "#b00020" : "inherit";
    }

    function urlBase64ToUint8Array(base64String) {
      const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
      const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");
      const rawData = window.atob(base64);
      const outputArray = new Uint8Array(rawData.length);
      for (let i = 0; i < rawData.length; i++) {
        outputArray[i] = rawData.charCodeAt(i);
      }
      return outputArray;
    }

    async function getRegistration() {
      if (!("serviceWorker" in navigator)) {
        throw new Error("Service workers are not supported in this browser.");
      }
      return navigator.serviceWorker.register("/qsl-digest-sw.js", { scope: "/notifications/" });
    }

    async function getAllLocalSubscriptions() {
      if (!("serviceWorker" in navigator)) {
        return [];
      }
      const registrations = await navigator.serviceWorker.getRegistrations();
      const result = [];
      for (const registration of registrations) {
        const subscription = await registration.pushManager.getSubscription();
        if (subscription) {
          result.push({ registration, subscription });
        }
      }
      return result;
    }

    async function subscribePush() {
      if (!publicVapidKey) {
        updateStatus("Web push is not configured on this server.", true);
        return;
      }

      const permission = await Notification.requestPermission();
      if (permission !== "granted") {
        updateStatus("Notification permission was not granted.", true);
        return;
      }

      const registration = await getRegistration();
      let subscription = await registration.pushManager.getSubscription();
      if (!subscription) {
        subscription = await registration.pushManager.subscribe({
          userVisibleOnly: true,
          applicationServerKey: urlBase64ToUint8Array(publicVapidKey),
        });
      }

      const data = subscription.toJSON();
      const response = await fetch("/api/v1/notifications/web-push/subscribe", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          endpoint: data.endpoint,
          keys: data.keys,
          platform: navigator.platform,
          user_agent: navigator.userAgent,
        }),
      });

      if (!response.ok) {
        throw new Error("Subscription registration failed.");
      }

      pushCount.textContent = String(parseInt(pushCount.textContent || "0", 10) + 1);
      updateStatus("Browser push notifications are enabled.");
    }

    async function unsubscribePush() {
      const subscriptions = await getAllLocalSubscriptions();
      if (!subscriptions.length) {
        updateStatus("No active browser push subscription found.");
        return;
      }

      const seenEndpoints = new Set();
      for (const { subscription } of subscriptions) {
        const data = subscription.toJSON();
        if (data.endpoint && !seenEndpoints.has(data.endpoint)) {
          seenEndpoints.add(data.endpoint);
          await fetch("/api/v1/notifications/web-push/unsubscribe", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ endpoint: data.endpoint }),
          });
        }
        await subscription.unsubscribe();
      }

      pushCount.textContent = "0";
      updateStatus("Browser push notifications are disabled.");
    }

    document.getElementById("enable-push-btn").addEventListener("click", async () => {
      try {
        await subscribePush();
      } catch (error) {
        updateStatus(error.message || "Unable to enable push notifications.", true);
      }
    });

    document.getElementById("disable-push-btn").addEventListener("click", async () => {
      try {
        await unsubscribePush();
      } catch (error) {
        updateStatus(error.message || "Unable to disable push notifications.", true);
      }
    });
  </script>
{% endblock %}
